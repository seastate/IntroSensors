\setchapterstyle{kao}
\setchapterpreamble[u]{\margintoc}
\chapter[Environmental sensing with voltage, current and resistance]{Introduction to circuits: Environmental sensing with voltage, current and resistance}
\labch{circuits_intro}
Natural environments and the ecosystems within them are governed by physical characteristics like temperature, light intensity, $O_2$ concentration, $pH$, seawater salinity, and wind or current velocity.
Instruments for environmental sensing generate electrical signals that vary with one or more of these characteristics.
For this to be useful, the relationship between electrical outputs and environmental inputs must be consistent and quantifiable.
The process of establishing this quantitative relationship is called \emph{calibration}.
A calibration usually must work in both directions:
First, the calibration is established by measuring the electrical signals across a relevant range of known environmental conditions.
Then,  electrical signals are acquired from unknown environmental samples, and the calibration is used to infer the conditions under which they were obtained.
This chapter will guide you through the methods and process of designing and building devices to measure electrical signals, and calibrating those devices to quantify environmental conditions.

Because most environmental characteristics vary continuously, the electrical signals generated by environmental sensors are also usually continuous.
These signals are referred to as \emph{analog} signals, to distinguish them from \emph{digital} signals like those you worked with in \refch{first_exercises}.
Digital signals are simply ``high'' or ``low'' --- usually determined by a voltage that is above or below a threshold voltage.
Because analog signals vary continuously, they potentially carry much more information.
However, analog signals must typically be measured much more accurately and precisely than digital signals.
For this reason, analog measurements are handled differently by microcontrollers, with distinct methods and constraints.

Most microcontrollers can directly measure just two parameters: voltage and time.
Unsurprisingly, the vast majority of analog sensors provide information using one or both of these parameters.
A voltage-based analog sensor typically has three connections: ground, \texttt{GND} (\texttt{0V}); an input voltage, $V_{in}$; and, a data output voltage, $V_{data}$.
The data output voltage, $V_{data}$, represents environmental characteristics in the form of a voltage that varies between \texttt{GND} and $V_{in}$.
For example, in \refsec{cal_therm}, you will measure temperature with a component called a thermistor.
A thermistor has a \emph{resistance} (impediment to the flow of electrons) that changes as a function of temperature.
You will combine the thermistor with another resistor in a way that causes the output voltage $V_{data}$ to change with temperature.
You will then use a microcontroller to measure $V_{data}$, calculate thermistor resistance, and use a calibration to infer the temperature.

A time-based sensor uses the duration of or interval between events as the key measurement.
For example, in \refsec{cal_sonar}, you will use an acoustic sensor to measure distance to a object.
In this case, the length of time between an initial event --- sending out a pulse of sound --- and a secondary event --- the echo of that pulse arriving back at the source --- indicates the round trip travel time for sound waves.
Calibrated by a knowledge of the speed of sound, this travel time indicates distance.

The following sections explain some electrical principles that you need to understand when working with voltage-based environmental sensors. You will apply that knowledge to measure battery voltage (an important parameter in a field-deployed device!) and thermistor temperature. You will then use time-based sensors to measure distance and light, and combine both time and voltage to measure wind or current velocity.
\todo{Textbox explaining font conventions for code, units and electrical quantities.}

%like the \texttt{3V3} pin in your \refch{first_exercises} circuits),
%The data connection takes on a voltage anywhere between
%
%have a is the process of generating
%
%calibration must be bidirectional
%
%In this chapter, we explore the relationships between characteristics of the environment --- \etc ---

\section{Measuring voltage}
\labsec{meas_volt}
Voltage is measured on a microcontroller using an \texttt{Analog to Digital Conversion} (\adc) pin.
\adc pins act as inputs, just as digital \texttt{GPIO} pins do in their input modes.
However, reading the value of a digital \texttt{GPIO} pin results in either 1 or 0 (``high'' or ``low''). In contrast, an \adc pin returns an integer that can span a range, e.g. between 0 and 1024.
That integer's value is proportional to the voltage applied to the \adc pin.

For example, in \htmladdnormallink{\texttt{Analog to Digital Conversion} on the ESP8366}{http://docs.micropython.org/en/v1.9.3/esp8266/esp8266/quickref.html\#adc-analog-to-digital-conversion}, an \adc value of 0 implies \texttt{0V}, \adc value of 1024 implies \texttt{1V}, and \adc value of 113 implies $\frac{113}{1024} \times 1\mathtt{V}$ or \texttt{0.11V}.
In general,
\begin{equation}\label{adc_volt}
V = \frac{ADC}{1024}
%V \mathsf{V} \mathrm{V} = \frac{ADC}{1024} \frac{\mathsf{ADC}}{1024} \frac{\mathrm{ADC}}{1024}
\end{equation}
for the \texttt{ESP8266}, where $ADC$ is the integer value read from the \adc pin, and $V$ is the applied voltage in units of \texttt{volts}
\sidenote[][*-8]{
	\begin{kaobox}[backgroundcolor=\SNcolor,frametitlebackgroundcolor=\SNcolor,frametitle=Resolve to change!]
		An important implication of Equation \ref{adc_volt} is a limit to the \htmladdnormallink{\emph{resolution}}{https://www.itl.nist.gov/div898/handbook/mpc/section4/mpc451.htm} of the \texttt{ESP8266}'s \adc.
		Resolution is the smallest increment of a physical characteristic that can be distinguished by a sensor.
		In this case, an increment of 1 in the integer value of the \texttt{ESP8266}'s \adc corresponds to a change of voltage, $\Delta V$, of
		\begin{equation}\label{adc_volt2}
		\Delta V = \frac{1~ \mathtt{volts}}{1024} = 0.000977~ \mathtt{volts}
		\end{equation}
		This means that, even if there were no measurement errors associated with accuracy and precision, the \adc reading could represent any voltage within a range of approximately $\pm \frac{1}{2}\Delta V$.
	\end{kaobox}
}.

\subsection{Voltage of an \texttt{18650} lithium-ion battery}
The task at hand in this section is to measure the voltage of a rechargeable lithium-ion battery called an \htmladdnormallink{``\texttt{18650}''}{https://en.wikipedia.org/wiki/Lithium-ion_battery}.
The name \texttt{18650} derives from its dimensions: an \texttt{18650} battery is \texttt{18mm} in diameter and \texttt{65mm} long.
\texttt{18650}s are a common standard of rechargeable battery, widely available and well suited to powering environmental sensors.

\texttt{18650} voltages typically range from 3.7-4.2V, depending on how charged they are, ambient temperature, \etc
For an instrument in the field, the capacity to monitor its own battery level can be valuable.
For example, an instrument on the verge of power failure can, if connected to the Internet, send a message indicating it needs maintenance.
Alternatively, it can be programmed to alter its sampling schedule to stretch whatever power remains over a longer duration, even if less frequently.

Monitoring battery voltage with an \adc that measures voltage seems like an easy task, right?

Well, it \emph{is} pretty easy.
But, there's a wrinkle we need to contend with: \adcs have strict limits to how large a voltage they can tolerate.
In fact, for many types of microcontroller these limits are quite low.
For \texttt{ESP8266}s, the limit is \texttt{1V}.
That's much lower than even a mostly discharged \texttt{18650} battery's voltage.
If we attach the terminals of an \texttt{18650} directly to an ESP8266 \adc, we risk destroying the \adc and possibly other components as well.

We need a way to \emph{represent} the voltage of an \texttt{18650} with a voltage that we know will never exceed \texttt{1V}.
To accomplish this, we'll create a sensor in the typical 3-connection analog format: \texttt{GND}, $V_{in}$ and $V_{data}$.
In this sensor, \texttt{GND} and $V_{in}$ will come from the \texttt{18650} terminals.
$V_{data}$ will come from the circuit we're about to design, in such a way as to insure that it accurately represents battery voltage according to a known calibration while staying within the \texttt{1V} limit.

\subsubsection{Ohm's Law for voltage, current and resistance}
The design of our current sensor is based on one of the fundamental laws governing electricity, \htmladdnormallink{Ohm's Law}{https://en.wikipedia.org/wiki/Ohm\%27s\_law}.
Ohm's Law defines the quantitative relationship between voltage, current and resistance across a \htmladdnormallink{\emph{resistor}}{https://en.wikipedia.org/wiki/Resistor}.
You used a resistor when you constructed a circuit to power an external LED in \refsec{ext_led}.
Though we did not go into the details there, the purpose of that resistor was to regulate the amount of current flowing through the LED.
How did we know which resistor to use?
We calculated it using Ohm's Law.

In a diagram of an electrical circuit, a resistor is illustrated by a zig-zag line:
\begin{figure}[h!]
		\labfig{res}
		\centering
%	\begin{center}
		\begin{tikzpicture}[american voltages]
		\draw
		(0,0) to [short,l=$V_{1}$, *-] (1,0)
		to [R, l=$R$, i_=$I$] (3,0)
		to [short,l=$V_{2}$, -*] (4,0);
		\end{tikzpicture}
		\caption[Circuit diagram: Resistor]{Circuit diagram of a resistor.}
%	\end{center}
\end{figure}

In this circuit, $R$ is the value of the resistor.
$V_1$ is the voltage imposed on the left wire from the resistor, and $V_2$ is the voltage imposed on the right wire.
The voltage drop across this resistor is $V = V_1 - V_2$.
The current flowing through the resistor is $I$.

According to Ohm's Law,
\begin{equation}\label{OhmsVIR}
V = I R
\end{equation}
In Equation \ref{OhmsVIR}, $V$ is the voltage difference measured across the resistor, in units of \htmladdnormallink{\texttt{volts}}{https://en.wikipedia.org/wiki/Volt}.
$I$ is the current (i.e., the flow of electrons) through the resistor, in units of \htmladdnormallink{\texttt{amperes}}{https://en.wikipedia.org/wiki/Ampere} (usually shortened to ``\texttt{amps}'').
$R$ is the \emph{resistance} of the conductor, in units of \htmladdnormallink{\texttt{ohms}}{https://en.wikipedia.org/wiki/Ampere}.


\begin{kaobox}[frametitle=Signs of things to come \dots]
Current consists of flowing electrons.
This means that whenever we refer to a value like $I$ to indicate current, we need to be clear about which direction of flow we count as positive.
This will become especially important when we work with more complex circuits later on.

In the circuit diagram, the small arrow above $I$ indicates the direction we choose to count current flow as positive.
We can choose either direction, but we must be consistent in using one direction or the other.
For that reason, the direction of positive current flow will always be indicated in the circuit diagrams in this book.

%Because no electrons are created or lost while passing through the resistor, the current is the same at every point in this simple circuit.

The arrow also tells us the direction in which to measure voltage drop:
The arrow always points away from the starting voltage ($V_1$) and towards the ending voltage ($V_2$).
So, the voltage drop in the diagram is $V=V_1-V_2$.

Current always flows from a higher voltage to a lower voltage.
That is, if $V>0$, current flows from left to right and $I$ takes on a positive value.
If $V<0$, current flows from right to left and $I$ takes on a negative value.
%We need only one variable for current, because the number of flowing electrons is not changed inside a resistor --- the current flowing in from the left side is the same as the current flowing out of the right side.
\end{kaobox}

%https://en.wikipedia.org/wiki/Hydraulic_analogy

%Two mathematically equivalent forms of Ohm's Law are found by solving for $I$ or $R$:
%\begin{eqnarray}
%I = \frac{V}{R} \label{OhmsIVR} \\
%R = \frac{V}{I}  \label{OhmsRVI}
%\end{eqnarray}
Together, the three forms\sidenote[][*-8]{
	\begin{kaobox}[backgroundcolor=\SNcolor,frametitlebackgroundcolor=\SNcolor,frametitle=Ohm I!]Ohm's Law states that the current $I$ through a resistor $R$ due to the voltage difference $V$ is
		\begin{equation*}%\label{OhmsVIR}
			V = I R
		\end{equation*}
		Two mathematically equivalent forms of Ohm's Law are found by solving for $I$ or $R$:
		\begin{eqnarray}
		I = \frac{V}{R} \label{OhmsIVR} \\
		R = \frac{V}{I}  \label{OhmsRVI}
		\end{eqnarray}
		Together, the three forms of Ohm's Law make clear that among the three quantities $V$, $I$ and $R$, any two known values determine the third.
	\end{kaobox}
} of Ohm's Law (Equations \ref{OhmsVIR}-\ref{OhmsRVI}) show us how to use two of the quantities $V$, $I$ and $R$ to determine the third.

For example:
\begin{itemize}
	\item  If we know that $I=0.5$ amps and $R=4$ ohms, Equation \ref{OhmsVIR} tells us that $V=0.5 \times 4 = 2$ volts.
	\item  If we know that $V=7$ amps and $R=2$ ohms, Equation \ref{OhmsIVR} tells us that $I= \frac{7}{2} = 3.5$ amps.
	\item  If we know that $V=12$ amps and $I=6$ ohms, Equation \ref{OhmsRVI} tells us that $R= \frac{12}{6} = 2$ ohms.
\end{itemize}

\subsubsection{Designing a \texttt{voltage divider} using Ohm's Law}
We'll now apply Ohm's Law several times to understand voltage, current and resistance in a configuration of two resistors called a \htmladdnormallink{\texttt{voltage divider}}{https://en.wikipedia.org/wiki/Voltage\_divider}.
A voltage divider is a simple circuit composed of two resistors, connected in \emph{series} so that a wire from one resistor is connected directly to one wire from the other.

\begin{figure}[h!]
		\labfig{volt_div}
		\centering
%	\begin{center}
		\begin{tikzpicture}[american voltages]
		\draw
		(0,0) to [short,l=$V_{in}$, *-] (1,0)
		to [R, l=$R_1$] (3,0)
		to [short, i_=$I$,l=$V_{data}$] (4,0)
		to [R, l=$R_2$] (6,0)
		to [short,l=GND, -*] (7,0);
		\end{tikzpicture}
		\caption[Voltage divider schematic]{Schematic diagram of a voltage divider circuit.}
%	\end{center}
\end{figure}


\todo{Textbox contrasting series and parallel connections.}
A voltage divider has the same 3-connection configuration as most analog sensors.
The open ends of the resistor pair are connected to voltage inputs, $V_{in}$ on the left side and \texttt{GND} on the right.
%In our case, one is connected to \texttt{GND} (\texttt{0V}), and the other to $V_{in}$.
%\todo{Image of voltage divider}
These form two of the three connections in our analog voltage sensor.

In a diagram of a circuit, a junction between two components is often called a \emph{node}.
The node between the two resistors is the third connection, the voltage output $V_{data}$.

What voltage does $V_{data}$ take on?

To calculate this voltage, we need to use the fact that any current flowing out of resistor $R_1$ must flow into the connected resistor, $R_2$.
That is, current is constant throughout the voltage divider circuit.
%In this simple circuit geometry, there is no other conductive path for it to take!
%In the voltage divider circuit schematic, this means that $I_1=I_2$.

With this constraint in mind, we can deduce the current flow through the circuit, the voltage $V_{data}$ at the middle node, and even the power the sensor uses while connected to \texttt{GND} and $V_{in}$.
The logic begins with applying Equation \ref{OhmsIVR} twice, once across each resistor:
\begin{itemize}
	\item Across resistor $R_1$, the voltage drop is $V_{in}-V_{data}$ \texttt{volts}.

	Therefore,
	\begin{equation}\label{vd1}
	I = \frac{V_{in}-V_{data}}{R_1}.
	\end{equation}
	\item Across resistor $R_2$, the voltage drop is $V_{data}-0$ \texttt{volts}.

	Therefore,
	\begin{equation}\label{vd2}
	I = \frac{V_{data}}{R_2}.
	\end{equation}
	\item Equating these expressions, we find that
	\begin{equation}\label{vd3}
	\frac{V_{in}-V_{data}}{R_1} = \frac{V_{data}}{R_2}.
	\end{equation}
\end{itemize}
By rearranging Equation \ref{vd3}, we can solve for $V_{data}$:
\begin{equation}\label{vd4}
V_{data} = V_{in} \frac{R_2}{R_1+R_2}
\end{equation}
That is, $V_{data}$ is always a fixed fraction of $V_{in}$, and that fraction is the same as the fraction $R_2$ represents of the total resistance $R_1+R_2$.

Equation \ref{vd4} is the information we need to design a voltage divider enabling an ESP8266 \adc to safely measure the voltage of an \texttt{18650} battery.
To leave a margin of safety, we'll assume the highest voltage an \texttt{18650} can reach is $V_{in}=5V$. Then, to meet the \texttt{1V} limit on $V_{data}$ (the \adc pin), our circuit must have
\begin{equation}\label{vd5}
V_{data} = V_{in} \frac{R_2}{R_1+R_2}  \le 1 .
\end{equation}
%\begin{equation}\label{vd5}
%V_{data} = V_{in} \frac{R_2}{R_1+R_2} = 5 \frac{R_2}{R_1+R_2} \le 1 .
%\end{equation}
Again simplifying, we find that whenever
\begin{equation}\label{vd6}
R_2 \le \frac{R_1}{V_{in}-1} %= \frac{R_1}{4}
%R_2 \le \frac{R_1}{4}
\end{equation}
the output voltage $V_{data}$ will be both proportional to $V_{in}$ and within the tolerance of the ESP8266 \adc.
In this case, $V_{in}-1 = 4$, so if $R_2$ is less than $\frac{R_1}{4}$ the voltage tolerance is satisfied.

Having measured $V_{data}$, we will then be able to infer $V_{in}$ by solving for it in Equation \ref{vd4},
\begin{equation}\label{vd7}
V_{in} = V_{data} \frac{R_1+R_2}{R_2}.
\end{equation}
Here, the proportionality constant $\frac{R_1+R_2}{R_2}$ is the \emph{theoretical} calibration for our analog voltage sensor.

An additional consideration --- power consumption --- helps us choose among the many possible resistor values, $R_1$ and $R_2$, that satisfy Equation \ref{vd6}.
As current flows through a resistor, some of the electrical power is converted to heat.
The amount of electrical power converted by a resistor to heat, in units of \htmladdnormallink{watts}{https://en.wikipedia.org/wiki/Watt}, is
\begin{equation}\label{watts}
W = V I = \frac{V^2}{R} = I^2 R.
\end{equation}
In this equation, the two rightmost expressions come from applying Ohm's Law to replace either $V$ or $I$.
Using what we know about the current and voltage in our voltage divider circuit (and some algebra) we can see that
\begin{equation}\label{watts2}
W = \frac{V_{in}^2}{R_1+R_2}
\end{equation}
That is, the power dissipated across both resistors of the voltage divider equals the square of the imposed voltage, divided by the total resistance.
This tells us that, for a given voltage, higher values of $R_1+R_2$ mean less power dissipated.
In a battery-powered field instrument, less dissipated power is generally a good thing --- it may mean that instruments can collect data for longer.
This suggests that, among resistor combinations that satisfy  Equation \ref{vd6}, those combinations in which $R_1+R_2$ is larger will be more economical of power.

Note that there are limits to reducing power losses by increasing $R_1+R_2$.
That is because the \adc pin, when measuring voltage, draws a tiny amount of current itself (the exact amount is poorly documented).
This can be neglected as long as this current is tiny compared to the total current flowing through the voltage divider.
But, sufficiently high resistor values will make the total current so small that the \adc might have an effect on the voltage it's measuring.

\subsubsection{\howto Design a voltage divider circuit}
\labsec{vd_design}
With these insights into the working principles of voltage dividers, you are now equipped to design your own voltage dividing circuit to measure \texttt{18650} battery voltage with your ESP8266's \adc.
In this design process, you will consider alternative choices of resistors.
You will exclude resistor combinations that exceed the \adc's voltage tolerance.
Among the remaining combinations, you will calculate power consumption and estimate the resolution %accuracy and precision
of its voltage measurements, as a basis for a final selection of resistors for your circuit design.
Then, in \refsec{vd_assem}, you will assemble your voltage divider design and assess its accuracy and precision.
\begin{enumerate}
	\item \textbf{Select a focal set of resistors, among those you have at hand.}

	Most resistor packages contain a wide range of resistances, spanning several orders of magnitude.
	These often come as series of different orders of magnitude, such as $10 \Omega$, $100 \Omega$, $1\mathtt{K} \Omega$, $10\mathtt{K} \Omega$, $100\mathtt{K} \Omega$, $1 \mathsf{M} \Omega$, or $47 \Omega$, $470 \Omega$, $4.7\mathtt{K} \Omega$, $47\mathtt{K} \Omega$, $470\mathtt{K} \Omega$, $4.7 \mathsf{M} \Omega$, \etc
	\todo{textbox explaining K and M notation.}

	\smallskip
	As an example, we'll assume here that we have four resistors: $10 \Omega$, $100 \Omega$, $47\mathtt{K} \Omega$ and $470\mathtt{K} \Omega$.
	You should adjust your calculations to reflect the resistors you have to work with.

	\item \textbf{Create a spreadsheet for voltage calculations.}

	Start by opening a new spreadsheet, e.g. in LibreOffice or MicroSoft Office.
	Save it under an informative name, like ``voltage\_divider\_calcs'' with the appropriate file extension.

	\item \textbf{Fill labels in the top line for the quantities you will enter or calculate.}

	These entries are, in order:
	\begin{table}[H]
	\centering
	\begin{small}
	\begin{tabular}{|c|c|c|c|c|c|c|c|c|}
		\hline
		\textbf{A}  & \textbf{B} & \textbf{C} & \textbf{D} & \textbf{E} & \textbf{F} & \textbf{G} & \textbf{H} & \textbf{I} \\
		\hline
		Vin  & R1 & R2 & R2/R1 & Vdata & Vdata<1? & I & W & Vres \\
		\hline
		&  &  &  &  &  &  &  &  \\
		\hline
	\end{tabular}
	\end{small}
	\end{table}
	We will now fill in the second row, column by column, to build a design tool for voltage dividers.

	\item \textbf{Enter $V_{in}$, $R_1$ and $R_2$ in the appropriate columns.}

	Here, $V_{in}$ is the maximum voltage we expect to see from the battery, with an error tolerance built in.
	A good choice for this is \texttt{5V}.

	\smallskip
	For the resistor values, choose any two of your focal resistor values.
	For our example, we have chosen $R_1=470\Omega$ and $R_2=47\Omega$.
	\begin{table}[H]
		\centering \begin{small}
		\begin{tabular}{|c|c|c|c|c|c|c|c|c|}
			\hline
			\textbf{A}  & \textbf{B} & \textbf{C} & \textbf{D} & \textbf{E} & \textbf{F} & \textbf{G} & \textbf{H} & \textbf{I} \\
			\hline
			Vin  & R1 & R2 & R2/R1 & Vdata & Vdata<1? & I & W & Vres \\
			\hline
			5 & 470  & 47 &  &  &  &  &  &  \\
			\hline
		\end{tabular}
	\end{small}
	\end{table}
	You will use these values to build the formulas in your spreadsheet.
	Then you can make extra copies or change the resistor values to find the best resistor combination.

	\item \textbf{Test whether the voltage tolerance condition, Equation \ref{vd6}, is satisfied.}

	First, enter the formula \lstinline{=C2/B2} in the spreadsheet cell below \texttt{R2/R1}.
	In this entry, the ``='' tells the spreadsheet you will enter a formula that should be calculated based on existing values in the spreadsheet.
	The result of this calculation is $R_2$ as a fraction of $R_1$.

	% This entry removed to save space
	%	Then, enter the formula \lstinline{=C2<(B2/(A1-1))} in the spreadsheet cell below \texttt{R2<R1/(Vin-1)?}.
	%	Here again, the  ``='' tells the spreadsheet you will enter a formula.
	%	In this case, though, the formula is a logical statement, \lstinline{C2<(B2/4)}, that is either True or False.
	\begin{table}[H]
	\centering \begin{small}
	\begin{tabular}{|c|c|c|c|c|c|c|c|c|}
		\hline
		\textbf{A}  & \textbf{B} & \textbf{C} & \textbf{D} & \textbf{E} & \textbf{F} & \textbf{G} & \textbf{H} & \textbf{I} \\
		\hline
		Vin  & R1 & R2 & R2/R1 & Vdata & Vdata<1? & I & W & Vres \\
		\hline
		5 & 470  & 47 & 0.1 &  &  &  &  &  \\
		\hline
	\end{tabular}
	\end{small}
	\end{table}
%	If the result of this calculation is \texttt{TRUE}, then the values for $R_1$ and $R_2$ satisfy the voltage limitations of the ESP8266 \adc.

	\item \textbf{Calculate the maximum output voltage, $V_{data}$, using Equation \ref{vd4}.}

	First, enter the formula \lstinline{=A2*C2/(B2+C2)} in the spreadsheet cell below \texttt{Vdata}.
	In this formula, the cell references correspond to the correct variables in Equation \ref{vd4}.

	Then, enter the formula \lstinline{=F2<1} in the spreadsheet cell below \texttt{Vdata<1?}.
	Here, again, the  ``='' tells the spreadsheet you will enter a formula.
	In this case, though, the formula is a logical statement, \lstinline{F2<1}, that is either true or false.
	This formula uses the result from the \texttt{Vdata} column; it returns \texttt{TRUE} if $V_{data} < 1$ \texttt{volt} and the voltage divider is safe for the ESP8266's \adc.
	\begin{table}[H]
	\centering \begin{small}
	\begin{tabular}{|c|c|c|c|c|c|c|c|c|}
		\hline
		\textbf{A}  & \textbf{B} & \textbf{C} & \textbf{D} & \textbf{E} & \textbf{F} & \textbf{G} & \textbf{H} & \textbf{I} \\
		\hline
		Vin  & R1 & R2 & R2/R1 & Vdata & Vdata<1? & I & W & Vres \\
		\hline
		5 & 470  & 47 & 0.1 & 0.455 & TRUE &  &  &  \\
		\hline
	\end{tabular}
	\end{small}
	\end{table}
	In this example, the new entries confirm that the voltage tolerance is satisfied.

	\item \textbf{Calculate current flowing through the voltage divider, and the power dissipated to heat.}

	First, enter the formula \lstinline{=A2/(B2+C2)} in the spreadsheet cell below \texttt{I}.

	Then, enter the formula \lstinline{=A2^2/(B2+C2)} in the spreadsheet cell below \texttt{W}.
	This formula corresponds to Equation \ref{watts2}, for calculating the power dissipated to heat in the voltage divider.
	\begin{table}[H]
	\centering \begin{small}
	\begin{tabular}{|c|c|c|c|c|c|c|c|c|}
		\hline
		\textbf{A}  & \textbf{B} & \textbf{C} & \textbf{D} & \textbf{E} & \textbf{F} & \textbf{G} & \textbf{H} & \textbf{I} \\
		\hline
		Vin  & R1 & R2 & R2/R1 & Vdata & Vdata<1? & I & W & Vres \\
		\hline
		5 & 470  & 47 & 0.1 & 0.455 & TRUE & 0.00967 & 0.0484 &  \\
		\hline
	\end{tabular}
	\end{small}
	\end{table}
	In this example, the new entries show that the current through the voltage divider at the assumed maximum input voltage is \texttt{0.00967 A}, or \texttt{9.67 mA}, and the power dissipated by that current is \texttt{0.0484 W}.

	\item \textbf{Calculate the resolution of \adc measurements of $V_{in}$.}

	Let's use the quantity $V_{res}$ to denote the smallest input voltage change we can resolve with our voltage divider/\adc combination --- that is, its \emph{resolution}.

	\smallskip
	In Equation \ref{adc_volt2}, we calculated that the theoretical resolution of the \texttt{ESP8266}'s \adc is $\frac{1}{1024}$, or just under $10^{-3}$ \texttt{volts}.
	What does this imply for our calculation of  $V_{res}$?
%	\begin{table}[H]
%	\centering
%	\begin{small}
%		\begin{tabular}{|c|c|c|c|c|c|c|c|c|}
%			\hline
%			Vin  & R1 & R2 & R2/R1 & Vdata & Vdata<1? & I & W & Vres \\
%			\hline
%			3.3 & 32648  & 100 & 3.06E-03 & 1.01E-02 & TRUE & 1.01E-04 & 3.33E-04 & 3.20E-01 \\
%			\hline
%			3.3 & 680  & 100 & 1.47E-01 & 4.23E-01 & TRUE & 4.23E-03 & 1.40E-02 & 7.62E-03 \\
%			\hline
%		\end{tabular}
%	\end{small}
%	\end{table}

	\smallskip
	By the design of our voltage divider, $V_{in}$ is always in constant proportion to $V_{data}$.
	That is, a change of input voltage, $\Delta V_{in}$, is always related to a change in \adc voltage, $\Delta V_{data}$, by
	\begin{equation}\label{vd9}
	\Delta V_{in} =  \Delta V_{data} \frac{V_{in}}{V_{data}}.
	\end{equation}
	Equation \ref{vd9} tells us that, if the smallest measurable \adc voltage change is $\Delta V_{data_{min}}=\frac{1}{1024}$, then the smallest measurable input voltage change, $\Delta V_{in_{min}}=V_{res}$, must be
	\begin{equation}\label{vd8}
	V_{res} = \frac{1}{1024} \frac{V_{in}}{V_{data}} = \frac{1}{1024} \frac{R_1+R_2}{R_2}.
\end{equation}
%
%	 varies from
%
%	In our voltage sensor, the \adc will measure $V_{data}$, each integer result from the \adc has this magnitude of uncertainty (plus any accuracy and precision errors).
%	The highest value that the \adc can return (when $V_{in}$ is at its maximum value, \texttt{5 volts}) is $V_{data}$.
%	This value is $1024 V_{data}$, and to satisfy the voltage tolerance we know that this number must be less than or equal to 1024.
%	Because the $0$-$1024 V_{data}$ integer range corresponds to the entire $0-5$ \texttt{volt} range of $V_{in}$, the resolution limit in $V_{in}$ must be
%	\begin{equation}\label{vd8}
%	\Delta V_{in} = \frac{V_{in}}{1024 V_{data}}.
%	\end{equation}
	To implement this calculation in your spreadsheet, enter the formula \lstinline{=(1/1024)*(B2+C2)/C2} in the spreadsheet cell below \texttt{Vres}.
	\begin{table}[H]
	\centering
	\begin{small}
	\begin{tabular}{|c|c|c|c|c|c|c|c|c|}
		\hline
		\textbf{A}  & \textbf{B} & \textbf{C} & \textbf{D} & \textbf{E} & \textbf{F} & \textbf{G} & \textbf{H} & \textbf{I} \\
		\hline
		Vin  & R1 & R2 & R2/R1 & Vdata & Vdata<1? & I & W & Vres \\
		\hline
		5 & 470  & 47 & 0.1 & 0.455 & TRUE & 0.00967 & 0.0484 & 0.0107 \\
		\hline
	\end{tabular}
	\end{small}
	\end{table}
	In this example, we see that each increment in the \adc reading corresponds to a range of \texttt{0.0107 volts} in $V_{in}$.

	\item \textbf{Copy your calculations into additional rows to test new combinations of resistors.}

	To replicate your calculations for other resistor values, select all the cells you filled out in the second row, and paste them into the row below.
	You can then change the $R_1$ and $R_2$ resistor values, and compare the results to previous combinations.

	For example, we can see the effects of substituting a $10 \Omega$ resistor for the $47 \Omega$ resistor, with
	\begin{table}[H]
	\centering \begin{small}
	\begin{tabular}{|c|c|c|c|c|c|c|c|c|}
		\hline
		\textbf{A}  & \textbf{B} & \textbf{C} & \textbf{D} & \textbf{E} & \textbf{F} & \textbf{G} & \textbf{H} & \textbf{I} \\
		\hline
		Vin  & R1 & R2 & R2/R1 & Vdata & Vdata<1? & I & W & Vres \\
		\hline
		5 & 470  & 47 & 0.1 & 0.455 & TRUE & 0.00967 & 0.0484 & 0.0107 \\
		\hline
		5 & 470  & 10 & 0.0213 & 0.104 & TRUE & 0.0104 & 0.0521 & 0.0469 \\
		\hline
	\end{tabular}
	\end{small}
	\end{table}
	By creating additional rows, you can now quickly and systematically explore a wide range of possible resistor combinations to determine which will make the best voltage divider for your analog voltage sensor.

\end{enumerate}

\loadMilestone{mlst:04a} % load milestone with tags id: mlst:04a


\subsubsection{\howto Assemble and test a voltage divider circuit}
\labsec{vd_assem}

Now that you've designed an analog voltage sensor for monitoring an \texttt{\texttt{18650}} battery, it's time to build it and see how it works!
\begin{marginfigure}[-0cm]
	\begin{center}
		\htmladdnormallink{\includegraphics[width=\MFW]{Fritzing/feather_voltage_divider2_bb.png}}{https://publicsensors.org/IntroSensors/Fritzing/feather_voltage_divider2_bb.png}
		\caption[Voltage divider schematic]{An illustration of the layout for an analog voltage sensor, using a \texttt{voltage divider} to measure voltage from an \texttt{\texttt{18650}} battery.
		In the schematic, jumpers that are not needed but may be left in place if already present are indicated in gray.}
		\labfig{feather_voltage_divider2}
	\end{center}
\end{marginfigure}
An example breadboard layout is given in \reffig{feather_voltage_divider2}.

Here's the step-by-step (\underline{be sure to do these in order}):
\begin{enumerate}
	\item \textbf{Select, label and test the resistors $R_1$ and $R_2$.}

	Resistors are labeled with \htmladdnormallink{colored bands}{https://en.wikipedia.org/wiki/Electronic\_color\_code} that indicate their resistance values.
	Online calculators, such as \htmladdnormallink{Digi-Key's Color Code Calculator}{https://www.digikey.com/en/resources/conversion-calculators/conversion-calculator-resistor-color-code-4-band} make it easy to translate these bands into numerical resistance values.

	\smallskip
	Even easier is to use a multimeter.
	\begin{itemize}
		\item[$\circ$] Choose resistors for the $R_1$ and $R_2$ values you identified as yielding the best voltage divider characteristics.
		\item[$\circ$] Measure the actual resistances using the multimeter.
		\item[$\circ$] Label each resistor with a piece of tape, identifying it as to the role it will play ($R_1$ or $R_2$) and its actual resistance.
	\end{itemize}
	By measuring and labeling, you account for the possibility that the actual resistances differ substantially from the nominal resistances.
	You also reduce the risk that you will accidentally reverse $R_1$ and $R_2$ in your circuit, which could destroy the \adc.

	\item \textbf{Insert your microcontroller in your breadboard, in the standard position.}

	\item \textbf{Insert the resistors into the breadboard.}

	\reffig{feather_voltage_divider2} shows one possible layout, but many variations are possible.
	The key requirements are that:
	\begin{itemize}
		\item[$\circ$] One end of both resistors connect by inserting into the same row.
		\item[$\circ$] The other ends of each resistor insert into otherwise empty rows.
	\end{itemize}
	\textbf{DOUBLE CHECK THAT YOUR $R_1$ AND $R_2$ RESISTORS ARE IN THE CORRECT POSITIONS, AS INDICATED IN \reffig{feather_voltage_divider2}}.

	\item \textbf{Use a jumper to connect the free end of your $R_2$ resistor to the negative rail.}

	\item \textbf{Insert your \texttt{\texttt{18650}} battery into the battery holder, making sure to have the positive terminal of the battery in the positive end of the battery holder.}

	\item \textbf{Insert the ``\texttt{-}'' (black) wire from the battery holder into the negative rail  (\texttt{GND}).}

	\item \textbf{Insert the ``\texttt{+}'' (red) wire from the battery holder to the free end of your $R_1$ resistor  (\texttt{Vin}).}

	\item \textbf{Test your connections!}

	At this point, there is voltage across the voltage divider.
	To insure your circuit is safe for your \texttt{ESP8266}'s \adc, confirm that:
	\begin{itemize}
		\item[$\circ$] Voltage across the free ends of $R_1$ and $R_2$ is in the range of \texttt{+3.6} to \texttt{+4.3 volts}.
		\item[$\circ$] Voltage across $R_2$ is in the range of \texttt{0} to \texttt{+1 volts}.
	\end{itemize}
	\textbf{IF EITHER OF THESE IS NOT TRUE, DO NOT PROCEED UNTIL YOU HAVE IDENTIFIED AND CORRECTED THE PROBLEM}.

	\item \textbf{Use a jumper to connect your \texttt{ESP8266} \texttt{GND} pin to the negative rail.}

	When you establish this connection, it insures that the ``zero'' voltage (\texttt{GND}) is the same for the battery, voltage divider and microcontroller.

	\item \textbf{Use a long jumper to connect your \texttt{ESP8266}'s \adc pin to the row with both $R_1$ and $R_2$ connections (\texttt{Vdata}).}
\end{enumerate}

	The hardware assembly is now complete.
	Now it's time for the software!

\begin{enumerate}[resume]
	\item \textbf{Connect a USB cable to your microcontroller, an open a \texttt{REPL} session.}

	\item \textbf{Create an \adc object, and use it to query the voltage of $V_{data}$.}
\begin{lstlisting}[language=Python]
from machine import ADC   # import the ADC module
adc = ADC(0)              # create an ADC object
adc.read()    # read the ADC and print the result
\end{lstlisting}

	\item \textbf{On your laptop or desktop, write a Micropython function that prints the battery voltage, $V_{in}$.}

	Use the following code to define your function, replacing the example resistor values with the correct values for your voltage divider:

	\lstinputlisting[language=Python,label=BatteryVoltage,caption={\htmladdnormallink{\texttt{BatteryVoltage.py}}{https://github.com/publicsensors/IntroSensors/blob/main/Codes/BatteryVoltage.py}: A Python function to calculate battery voltage using the \adc and a voltage divider.}]{Codes/BatteryVoltage.py}

	\item \textbf{Execute your function on your microcontroller.}

	You can load this function either using the \texttt{<ctrl>-e/<ctrl>-d} sequence to paste it into a \texttt{REPL} session, or by transferring the file and importing it.
	Either way, the commands (with resistor values modified)
\begin{lstlisting}[language=Python]
from BatteryVoltage import battery_voltage
battery_voltage(R1=470.,R2=47.)
\end{lstlisting}
	should now return a measurement of your \texttt{\texttt{18650}} battery voltage.
	If you change to other resistor values, you can calculate voltage for the new voltage divider by changing the \texttt{R1} and \texttt{R2} arguments of the function.
\end{enumerate}

\loadMilestone{mlst:04b} % load milestone with tags id: mlst:04b

%\vspace{3 cm}
%\begin{itemize}
%	\item Quantities and units
%	\item Analogies with pipe flow
%	\item Ohm's Law
%	\item voltage-based analog sensors: thermistors
%	\item time-based analog sensors: sonar \& light
%\end{itemize}
%
%\begin{itemize}
%	\item multimeters
%	\item ADC on ESP8266
%	\item how-to: design a voltage divider
%	\item how-to: build a voltage divider
%\end{itemize}

\section{Environmental sensing with voltage: measure temperature with a thermistor}
\labsec{cal_therm}
A \htmladdnormallink{thermistor}{https://en.wikipedia.org/wiki/Thermistor} is an electrical component whose resistance changes with temperature.
Thermistors are readily available and inexpensive, and low cost temperature sensors made from them can have very good accuracy and precision.
Unsurprisingly, thermistors are widely used as temperature sensors in industry and household appliances.
For example, the temperature in refrigerators and ovens are often controlled by circuits using a thermistor to sense temperature.
In this section you will design, assemble and calibrate an analog sensor using a thermistor, and use it to measure variations in environmental temperature.

The voltage divider you built in \refsec{meas_volt} was designed to measure voltage from a battery. % that was outside the \texttt{ESP8266} \adc's tolerance limits.
In the design process, you used Ohm's Law to deduce the unknown voltage, $V_{in}$, from a known pair of resistors $R_1$ and $R_2$ and the measured output voltage, $V_{data}$.
As Equation \ref{OhmsRVI} shows, Ohm's Law has an equivalent application in deducing resistance from known voltage and current.
This suggests that, in a voltage divider where $V_{in}$ and either $R_1$ or $R_2$ are known, $V_{data}$ could be used to infer the other, unknown resistor value.
%This suggests that a voltage divider in which both $V_{in}$, $V_{data}$ and either $R_1$ or $R_2$ are known could be used to infer the other, unknown resistor value.

The analog temperature sensor you will make uses a voltage divider in this way.
The unknown resistor in this voltage divider will be a thermistor.
Quantifying this thermistor's resistance --- combined with a calibration of how its resistance varies as a function of temperature --- will enable you to use your microcontroller to measure ambient temperature.

Using Equation \ref{vd4} as a starting point, we have two options.
We could use the thermistor to replace $R_1$.
In that case, solving Equation \ref{vd4} for $R_1 = R_{therm}$ gives us
\begin{equation}\label{therm1}
R_{therm} = \frac{V_{in}-V_{data}}{V_{data}}R_2.
\end{equation}
Alternatively, we could use the thermistor to replace $R_2$.
Then, solving Equation \ref{vd4} for $R_2 = R_{therm}$ gives us
\begin{equation}\label{therm2}
R_{therm} = \frac{V_{data}}{V_{in}-V_{data}}R_1.
\end{equation}
We do not know ahead of time which strategy will yield a better temperature sensor.
Which resistor to replace, and what value to choose for the remaining resistor, will emerge from the sensor design process.

\subsection{Thermistor temperature-resistance curves}
Thermistors are usually referred to by their \texttt{nominal resistance value}, which is their designed resistance at the reference temperature, $25^\circ$ \texttt{C} ($77^\circ$ \texttt{F}).
Common nominal resistance values for thermistors range from $100\Omega$ through $100k\Omega$.
Within this range are many nominal resistance values that are somewhat standard for specific purposes.
For example, many 3D printers use a $22k\Omega$ thermistor to measure the temperature at which melted plastic is being extruded to build up a part.

The most common type of thermistor in temperature sensors is a \texttt{``negative temperature coefficient''} (\texttt{NTC}) thermistor.
In an \texttt{NTC} thermistor, the resistance is lower at higher temperatures, and higher at lower temperatures.
(The converse --- a \texttt{``positive temperature coefficient''} or \texttt{PTC} thermistor, has higher resistance at higher temperatures, and lower resistance at lower temperatures.)
This change in resistance with temperature is what makes a thermistor suitable as the basis of a temperature sensor.
However, it also means that we must anticipate the entire range of possible resistance values in our circuit design, to get the best possible resolution while insuring that the voltage divider will never exceed the \adc voltage tolerance.

%To evaluate alternative configurations for a voltage divider measuring thermistor resistance, we need to consider how that resistance varies over the relevant range of temperatures.
%\texttt{NTC} means that resistance goes down with increasing temperature.
A systematic study of temperature-resistance curves for \texttt{NTC} thermistors was published in 1968 by Steinhard and Hart \cite{STEINHART1968497}.
The formula that they found to best describe these curves is known as the \htmladdnormallink{\texttt{Steinhart-Hart equation}}{https://en.wikipedia.org/wiki/Steinhart\%E2\%80\%93Hart\_equation},
\begin{equation}\label{therm3}
\frac{1}{T_{k}} = A + B \ln R_{th} + C (\ln R_{th})^3.
\end{equation}
In this equation, $T_{k}$ is thermistor temperature in \texttt{kelvins}.
$R_{th}$ is resistance in \texttt{ohms}.
$A$, $B$ and $C$ are calibration constants --- called \texttt{Steinhart-Hart coefficients} ---  that are determined for a given thermistor by measuring its resistance at three known temperatures.
If the three calibration temperatures are $T_{k,1}$, $T_{k,2}$ and $T_{k,3}$, and the corresponding resistances are $R_1$, $R_2$ and $R_3$, then the following formulas determine $A$, $B$ and $C$:
\begin{eqnarray}
L_1 = \ln R_1, ~L_2 = \ln R_2, ~L_3 = \ln R_3  \non \\
Y_1 = \frac{1}{T_{k,1}}, ~Y_2 = \frac{1}{T_{k,2}}, ~Y_3 = \frac{1}{T_{k,3}} \non \\
\gamma_2 = \frac{Y_2-Y_1}{L_2-L_1}, \gamma_3 = \frac{Y_3-Y_1}{L_3-L_1} \non \\
C = \frac{\gamma_3-\gamma_2}{L_3-L_2} (L_1+L_2+L_3)^{-1}  \label{therm4}\\
B = \gamma_2 - C(L_1^2 + L_1 L_2 + L_2^2) \non \\
A = Y_1 - (B+L_1^2 C) L_1 \non
\end{eqnarray}
It's sometimes useful to calculate a thermistor's resistance, $R_{th}$, from its temperature (that is, the \emph{inverse} of Equation \ref{therm3}).
One approach is through trial and error --- plugging a few guesses of $R_{th}$ into Equation \ref{therm3}), it's usually possible to come quite close to a specific $T_k$.
However, an explicit formula is available:
\begin{equation}\label{therm5}
R_{th} = e^{\left(\sqrt[3](y-x) - \sqrt[3](y+x)\right)} ,
%R_{th} = \exp\left(\sqrt[3](y-x) - \sqrt[3](y+x)\right) ,
\end{equation}
where
\begin{equation}\label{therm6}
x = \frac{1}{2C} \left( A - \frac{1}{T_{k}} \right), ~ y = \sqrt{\left(\frac{B}{3C}\right)^3+x^2}.
\end{equation}
These formulas provide the theoretical basis for calibrating your thermistor.

%http://www.aetsolar.com/literature/Manuals/TempVsResistChart.pdf

\subsubsection{\howto Calibrate a thermistor}
\labsec{therm_cal}
The first step in designing a thermistor-based temperature sensor is to calibrate its temperature-resistance curve by determining its Steinhart-Hart coefficients.
In this section, you will create simple water baths at three known temperatures $T_{k,1}$, $T_{k,2}$ and $T_{k,3}$, and use them to measure thermistor resistances $R_1$, $R_2$ and $R_3$ in Equation \ref{therm3}.

You will then use Equations \ref{therm3}--\ref{therm6} to calculate the Steinhart-Hart coefficients for your thermistor.
Establishing the Steinhart-Hart coefficients calibrates your thermistor, enabling you to calculate temperature from resistance and \textit{vice versa}.

It's worth noting that, to be good calibration temperatures, $T_{k,1}$, $T_{k,2}$ and $T_{k,3}$ should span all or most of the temperature range of interest.
Furthermore, they should ideally be spaced roughly equally apart within this range.
This is so that, to the extent possible, the Steinhart-Hart equations will be used to \texttt{interpolate} rather than \texttt{extrapolate} the temperature-resistance relationship.
As you may have found in previous scientific work, extrapolation often magnifies small errors in calibration such that they become disproportionately large far from measured data points.

In the calibration procedure below, we will illustrate the steps using example values from a $10k\Omega$ thermistor.
Substitute the values you obtain from your thermistor into these calculations.
\begin{enumerate}
	\item \textbf{Prepare water baths at three different temperatures.}

	Typically, most laboratory thermometers give temperature in $^\circ$ \texttt{Celsius}.
	Remember that temperature in Celsius, $T_c$, is related to $T_k$ by
	\begin{equation*}
		T_k = T_c + 273.15, ~T_c = T_k - 273.15.
	\end{equation*}
	To use water bath temperatures measured in \texttt{Celsius} for thermistor calibration, you must either convert them to $^\circ$ \texttt{Kelvin} using the formula above, or use the version of the Python scripts below that does that conversion for you.

	\smallskip
%	To be good calibration temperatures, $T_{k,1}$, $T_{k,2}$ and $T_{k,3}$ should span all or most of the temperature range of interest, and be spaced roughly equally apart within this range.
	In most classrooms and laboratories, three suitable temperatures that are easy to produce in water baths are:
	\begin{itemize}
		\item[$\circ$] $0^\circ$ \texttt{C}, which is the equilibruim temperature of a mixture of frozen and liquid fresh water.
		\item[$\circ$] $100^\circ$ \texttt{C}, which is the boiling temperature of fresh water.
		\item[$\circ$] Room temperature, which is usually close to $25^\circ$ \texttt{C}.
%  Human body temp: $36.5–37.5^\circ$ \texttt{C}
	\end{itemize}

	A good way to create ``water baths'' at these three temperatures for thermistor calibration is with paper bowls or cups, filled with a water/ice mixture, boiling water and room temperature water.
	Cover each bath with a lid, so that it maintains its temperature for longer and does not cool through evaporation.
	Confirm the actual temperatures of your water baths with the most accurate thermometer you can find, e.g. by inserting it through a small hole in the lid.

	\item \textbf{Prepare your thermistor for resistance measurements.}

	The goal in this step is to enable you to measure resistance across the thermistor with a multimeter, while that thermistor is held at known temperatures by the water baths.
	We leave it to your ingenuity to come up with effective, creative solutions to the materials you have on hand.

	\smallskip
	We'll illustrate with two examples, both of which are inexpensive and easily obtained $10k\Omega$ thermistors.\todo{pictures of Thermistors A and B}
	However, many other thermistor types and water bath arrangements are workable.
	\begin{itemize}
		\item[$\circ$] \texttt{Thermistor A} is a ``bead'' thermistor, with two bare wires.
		This kind of thermistor responds quickly to temperature changes, but is not protected from water or other corrosive or conductive liquids.

		\smallskip
		To calibrate \texttt{Thermistor A}, use removable tape (like painter's masking tape) to attach it snugly to the outside of the water baths
		It should directly touch the surface of the water bath, to conduct heat as quickly as possible from the water bath surface.
		Then, cover the thermistor with a layer of foam or folded paper towels to insulate it from the surrounding air.
		Keep in mind that the wires can conduct heat into or out of the thermistor, so ideally they will also be in contact with the bath and covered by the insulation.
		%Be sure, though, to leave enough of the wires exposed to connect to multimeter leads to measure resistance.

		\item[$\circ$] \texttt{Thermistor B} is ``potted'', meaning it is encased in a protective stainless steel sleeve, and embedded in epoxy or some other sealant.
		This casing means that the thermistor is waterproof --- it can be submerged directly into the water baths.
		However, because the casing retains a significant amount of heat, potted sensors can be slower to respond to temperature changes than bead thermistors.

		\smallskip
		To calibrate \texttt{Thermistor B}, immerse the thermistor entirely within the water bath, with its wires coming out through a small hole in the lid.

	\end{itemize}

	\item \textbf{Measure resistance at each water bath temperature with a multimeter.}

	In making these measurements, keep in mind:
	\begin{itemize}
		\item[$\circ$] The \texttt{equilibration time} of the thermistor.
		This is the time it takes for the interior of the thermistor to equalize in temperature with the surface of the water bath.
		You can get an estimate of the equilibration time by watching the resistance measured on a multimeter change immediately after you place the thermistor in contact with a surface of different temperature.
		Typical equilibration times range from a few seconds to several minutes.
		\item[$\circ$] %Multimeters also have internal equilibration times.
		Some multimeters have a significant amount of measurement noise, especially for very low or very high resistance values.
		When making your measurements, wait until the resistance value appears to stabilize.
		Then, record the resistance value at five times, spaced several seconds apart.
		Take the median of these as the most accurate resistance measurement.
	\end{itemize}

	\item \textbf{Calculate the Steinhart-Hart coefficients.}

	The Python functions below enable you to calculate the Steinhart-Hart coefficients for your thermistor.
	To use them, substitute your measured temperature and resistance values for the default \texttt{T}'s and \texttt{R}'s.
	You may run these functions on your computer or, using the \texttt{<ctrl>-e / <ctrl>-d} technique, copy and run them on your microcontroller.

	\smallskip
	Use \lstinline{SH_coeffs_kelvins} if your temperatures are in $^\circ$\texttt{Kelvin}, and \lstinline{SH_coeffs_celsius} if your temperatures are in $^\circ$\texttt{Celsius}. Both functions return the Steinhart-Hart coefficients \lstinline{(A, B, C)} as a Python tuple.
	\lstinputlisting[language=Python,label=SteinhartHart,caption={\htmladdnormallink{\texttt{SteinhartHart.py}}{https://github.com/publicsensors/IntroSensors/blob/main/Codes/SteinhartHart.py}: Python functions to calculate Steinhart-Hart coefficients for thermistor calibration.}]{Codes/SteinhartHart.py}


	\item \textbf{Verify the resistor and temperature calculations.}

	The Python functions below calculate temperature from resistance and \textit{vice versa} for a calibrated thermistor.
	\lstinputlisting[language=Python,label=thermistor,caption={\htmladdnormallink{\texttt{thermistor.py}}{https://github.com/publicsensors/IntroSensors/blob/main/Codes/thermistor.py}: Python functions to calculate temperature from resistance and \textit{vice versa} for a calibrated thermistor.}]{Codes/thermistor.py}
	As an initial test, try calculations with your known values: $R_1$ from $T_{k,1}$, $T_{k,2}$ from $R_2$, \etc
	For \emph{consistency}, you should get the same result as you entered for your calibration.

	\smallskip
	Next, use both a thermometer and your thermistor to measure another temperature, e.g. outside or in an unheated storage space, or in a water bath at a new temperature.
	What is the percent error between the thermometer and your thermistor temperature readings?

\end{enumerate}
\loadMilestone{mlst:04c} % load milestone with tags id: mlst:04c


\subsection{Thermistor circuit design}
To design a circuit that effectively uses a thermistor to measure environmental temperatures, you will use the tools you developed in the last two sections: A calibration enabling you to calculate your thermistor's resistance across the relevant range of temperatures, and a spreadsheet enabling you to calculate which resistor combinations satisfy the \texttt{ESP8266}'s \adc voltage tolerance.

There are two circuit configurations that you need to consider:
\begin{itemize}
	\item Configuration 1, in which the thermistor replaces resistor $R_1$ from the voltage divider circuit:
	\begin{figure}[H]
		\centering
%	\begin{center}
		\begin{tikzpicture}[american voltages]
		\draw
		(0,0) to [short,l=$V_{in}$, *-] (1,0)
		to [thRn, l=$RTH_1$] (3,0)
		to [short, i_=$I$,l=$V_{data}$] (4,0)
		to [R, l=$R_2$] (6,0)
		to [short,l=GND, -*] (7,0);
		\end{tikzpicture}
		\caption[Thermistor circuit \#1]{Schematic diagram of a voltage divider circuit, with the thermistor replacing resistor $R_1$.}
		\labfig{therm_cir1}
%	\end{center}
	\end{figure}

	\item Configuration 2, in which the thermistor replaces resistor $R_2$ from the voltage divider circuit:
	\begin{figure}[H]
		\centering
%	\begin{center}
		\begin{tikzpicture}[american voltages]
		\draw
		(0,0) to [short,l=$V_{in}$, *-] (1,0)
		to [R, l=$R_1$] (3,0)
		to [short, i_=$I$,l=$V_{data}$] (4,0)
		to [thRn, l=$RTH_2$] (6,0)
		to [short,l=GND, -*] (7,0);
		\end{tikzpicture}
		\caption[Thermistor circuit \#2]{Schematic diagram of a voltage divider circuit, with the thermistor replacing resistor $R_2$.}
		\labfig{therm_cir2}
%	\end{center}
	\end{figure}
\end{itemize}
In these circuit diagrams, the box with the diagonal line represents the thermistor, in which resistance is modulated by temperature. We have labeled the thermistor in these positions $RTH_1$ and $RTH_2$, to remind us that these thermistors replace resistors $R_1$ and $R_2$, respectively, in our voltage divider calculations.

\subsubsection{\howto Design a voltage divider for a thermistor}
\labsec{therm_des}
\begin{enumerate}
	\item \textbf{Make two copies of the voltage divider calculations spreadsheet from \refsec{vd_design}.}

	Save one with a name that includes something like ``\texttt{RTH1}''. You'll use this one to make calculations for Configuration 1.
	Likewise, save the other with an informative name that includes something like ``\texttt{RTH2}''.

	\item \textbf{Modify the \texttt{RTH1} spreadsheet for the thermistor circuit.}

	Starting with the voltage divider spreadsheet:
	\begin{itemize}
		\item[$\circ$] \textbf{Change the entries under the \texttt{Vin} column heading to \texttt{3.3}.}
		This reflects the fact that we will use the \texttt{3V3} pin to power the thermistor circuit. This pin always outputs exactly \texttt{3.3 volts}.

%		\item[$\circ$] Change the logical test in the fifth column to read \lstinline{R2<=R1/2.3?}. Then, change the formula in the rest of the fifth column to read \lstinline{=C2<(B2/2.3)}. This reflects the criterion on resistances to meet the voltage tolerance with the $V_{in}=3.3$ \texttt{volts}.
%
		\item[$\circ$] \textbf{In the top row, change the \texttt{R1} column header to \texttt{RTH1}.}

		For neatness, make the same change in the \texttt{R2/R1} header, to \texttt{R2/RTH1}.
		\item[$\circ$] \textbf{In the top row under the \texttt{RTH1} column header, enter the thermistor resistance you measured at the lowest temperature, $0^\circ$\texttt{C}.}
		\item[$\circ$] \textbf{In the next row, replace the \texttt{RTH1} column resistance with the thermistor resistance you measured at the highest temperature, $100^\circ$\texttt{C}.}
		These represent the whole range of resistances that can occur in the voltage divider within the calibrated interval, $0-100^\circ$\texttt{C}.

		\item[$\circ$] \textbf{Copy a candidate $R_2$ resistor value into \underline{both} rows under the \texttt{R2} column.}

		Your spreadsheet rows will then look something like this (using $R_2=100\Omega$ resistors as an example):
\begin{table}[H]
	\centering
	\begin{small}
		\begin{tabular}{|c|c|c|c|c|c|c|c|c|}
		\hline
			\textbf{A}  & \textbf{B} & \textbf{C} & \textbf{D} & \textbf{E} & \textbf{F} & \textbf{G} & \textbf{H} & \textbf{I} \\
			\hline
			Vin  & RTH1 & R2 & R2/RTH1 & Vdata & Vdata<1? & I & W & Vres \\
			\hline
			3.3 & 32648  & 100 & 3.06E-03 & 1.01E-02 & TRUE & 1.01E-04 & 3.33E-04 & 3.20E-01 \\
			\hline
			3.3 & 680  & 100 & 1.47E-01 & 4.23E-01 & TRUE & 4.23E-03 & 1.40E-02 & 7.62E-03 \\
			\hline
		\end{tabular}
	\end{small}
\end{table}

%		\item[$\circ$] \textbf{Examine the results in the remaining }

	\end{itemize}


	\item \textbf{Calculate ``self-heating'' of the thermistor due to dissipated electrical energy.}

	In the ``\texttt{W}'' column of your spreadsheet, you calculate the rate at which electrical power is lost to heat in the voltage divider.
	This is an important piece of information, because high rates of power dissipation can discharge the battery faster than necessary.

	\smallskip
	In our thermistor circuit, however, power dissipated to heat plays another role --- it heats the temperature sensor!
	If the thermistor itself is generating a substantial amount of heat, that could cause artifacts in its temperature readings.

	\smallskip
	To calculate the heat generation inside the thermistor, $W_{th}$, we can again use Equation \ref{watts}.
	Because we have already calculated the current, $I$, the simplest approach is to calculate $W_{th}$ as the product of $I^2$ and thermistor resistance.
\begin{itemize}
	\item[$\circ$] \textbf{Add a column header, \texttt{WTH1}, in the column after \texttt{Vres}.}
	\item[$\circ$] \textbf{Enter the formula \lstinline{=(H2^2)*B2} into the cells below \texttt{WTH1}.}
\end{itemize}
	Your spreadsheet will now look something like this:
\begin{table}[H]
	\centering
	\begin{small}
		\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|}
			\hline
			\textbf{A}  & \textbf{B} & \textbf{C} & \textbf{D} & \textbf{E} & \textbf{F} & \textbf{G} & \textbf{H} & \textbf{I} & \textbf{J} \\
			\hline
			Vin  & RTH1 & R2 & R2/RTH1 & Vdata & Vdata<1? & I & W & Vres & WTH1\\
			\hline
			3.3 & 32648  & 100 & 3.06E-03 & 1.01E-02 & TRUE & 1.01E-04 & 3.33E-04 & 3.20E-01 & 3.32E-04\\
			\hline
			3.3 & 680  & 100 & 1.47E-01 & 4.23E-01 & TRUE & 4.23E-03 & 1.40E-02 & 7.62E-03 & 1.22E-02\\
			\hline
		\end{tabular}
	\end{small}
\end{table}
	where the last column is the heat (in \texttt{watts}) generated in the thermistor.

	\item \textbf{Explore alternative resistor values, by making copies of the two rows of calculations, and entering different values for \texttt{R2}.}

	Does the new resistance value satisfy the \adc voltage tolerance?\sidenote[][*-25]{
		\begin{kaobox}[backgroundcolor=\SNcolor,frametitlebackgroundcolor=\SNcolor,frametitle=Resist-metic]As we found in the voltage divider discussion, the total resistance of two resistors connected in \emph{series} (one connected end to end with the other) is simply the sum of their individual resistances: $R_{total}=R_1+R_2$.
			You can use this fact if you want to use a resistor value that you don't have in hand.
			For example, if you have $510\Omega$ and $220\Omega$ resistors, you can attach them in series to form a $510+220=730\Omega$ resistor.
		\end{kaobox}
	}
	Is the resolution better or worse with new \texttt{R2} resistances?
	Are the total power dissipation and the heat generated inside the thermistor larger or smaller than the previous \texttt{R2} choices?

	\item \textbf{Repeat all the above steps for the \texttt{RTH2} spreadsheet, but this time replacing \texttt{R2} with \texttt{RTH2}.}

	In this case, the formula for \texttt{WTH2} is \lstinline{=(H2^2)*C2}.
	The result (using $R_1=100k\Omega$ as an example) will be similar to:
\begin{table}[H]
	\centering
	\begin{small}
		\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|}
			\hline
			\textbf{A}  & \textbf{B} & \textbf{C} & \textbf{D} & \textbf{E} & \textbf{F} & \textbf{G} & \textbf{H} & \textbf{I} & \textbf{J} \\
			\hline
			Vin  & R1 & RTH2 & RTH2/R1 & Vdata & Vdata<1? & I & W & Vres & WTH2\\
			\hline
			3.3 & 1.00E+05  & 32648 & 3.26E-01 & 8.12E-01 & TRUE & 2.49E-05 & 8.21E-05 & 9.37E-03 & 2.02E-05\\
			\hline
			3.3 & 1.00E+05  & 680 & 6.80E-03 & 2.23E-02 & TRUE & 3.28E-05 & 1.08E-04 & 1.45E-01 & 7.31E-07\\
			\hline
		\end{tabular}
	\end{small}
\end{table}

\end{enumerate}
\loadMilestone{mlst:04d} % load milestone with tags id: mlst:04c


\subsection{Thermistor circuit assembly and programming}
Laying out and assembling a voltage dividing circuit to measure temperature with a thermistor requires only a few changes from the voltage divider you built in \refsec{vd_assem}.
Then, measuring temperature involves three steps that happen in Python scripts:
\begin{itemize}
	\item Use the \adc to measure $V_{data}$.
	\item Use Equation \ref{therm1} or \ref{therm2} (depending on your circuit configuration) to infer the thermistor resistance $R_{therm}$ from $V_{data}$.
	\item Use your thermistor calibration from \refsec{therm_cal} to infer temperature from $R_{therm}$.
\end{itemize}
The following \textit{HOW-TO} takes you through these steps.

\subsubsection{\howto Build and test a thermistor circuit}
If you have chosen Configuration 2, your circuit layout will be similar to \reffig{feather_thermistor}.
If you have chosen Configuration 1, your circuit layout will have the thermistor in position \texttt{R1} rather than \texttt{R2}, but be otherwise similar to \reffig{feather_thermistor}.

\labsec{therm_build}
\begin{marginfigure}[-8cm]
	\begin{center}
		\htmladdnormallink{\includegraphics[width=\MFW]{Fritzing/feather_thermistor_bb.png}}{https://publicsensors.org/IntroSensors/Fritzing/feather_thermistor_bb.png}
		\caption[Thermistor circuit schematic]{An illustration of the layout for a circuit using a thermistor to measure temperature.
		This schematic represents Configuration 2, in which the thermistor (here labeled \texttt{RTH2}) takes the place of resistor $R_2$ in the original voltage divider circuit.
		In Configuration 1, the thermistor would instead take the place of resistor $R_1$.
		In the schematic, jumpers that are not needed but may be left in place if already present are indicated in gray.}
		\labfig{feather_thermistor}
	\end{center}
\end{marginfigure}
\begin{enumerate}
	\item \textbf{Disconnect your microcontroller from USB power.}

	\item \textbf{If you are modifying the battery voltage circuit, disconnect one end of the jumper to the \adc.}

	Both these precautions are to prevent accidentally exposing your \adc to voltages higher than its tolerance, while you build and check your circuit.

	\item \textbf{Assemble and double check the thermistor circuit.}

Compared to the battery voltage circuit, the changes are:
	\begin{itemize}
		\item[$\circ$] Use a jumper to connect the power rail to the open end of resistor \texttt{R1} (or \texttt{RTH1} if you are using Configuration 1).

		The power rail, which is connected to the \texttt{ESP8266}'s \texttt{3V3} pin, supplies positive voltage (instead of the battery in the original circuit).
		\item[$\circ$] \textbf{Replace the appropriate resistor (\texttt{R1} for Configuration 1, \texttt{R2} for Configuration 2) with the thermistor.}
		\item[$\circ$] \textbf{Replace the other resistor (\texttt{R2} for Configuration 1, \texttt{R1} for Configuration 2) with the resistor you chose in your design analysis in \refsec{therm_des}.}
	\end{itemize}

	\item \textbf{With the \adc jumper still disconnected, plug the microcontroller into USB power.}

	\item \textbf{Use a multimeter to check that voltage $0 \le V_{data} \le 1$.}

	At this point, the voltage divider should be powered up and operating as it would during temperature measurements.

	\smallskip
	IF THE CONDITION $0 \le V_{data} \le 1$ IS NOT MET, STOP AND DEBUG YOUR CIRCUIT.

	\smallskip
	Do not proceed until you've diagnosed and fixed the problem in the circuit --- it could destroy the \adc.

	\item \textbf{Connect the \adc-\texttt{Vdata} jumper.}

\end{enumerate}
That's it for the hardware.
Now for the software!

\begin{enumerate}[resume]
	\item \textbf{Make a copy of the Python script }\lstinline{BatteryVoltage.py} \textbf{from \refsec{vd_assem}, and save it with an informative name such as as }\lstinline{ThermResist.py}\textbf{.}

	\item \textbf{Modify this script so that it calculates thermistor resistance.}

	The necessary changes are:
	\begin{itemize}
		\item[$\circ$] Change the name of the \lstinline{battery_voltage} function to an informative name, e.g. \lstinline{therm_resistRTH2} if you are using Configuration 2.

		\item[$\circ$] \textbf{Change the \texttt{arguments} of the function from the parameters in the original voltage divider,} \lstinline{R1=470.,R2=47.}\textbf{, to the parameters in the thermistor circuit:} \lstinline{R1=1.e5,vin=3.3}\textbf{.}

		\item[$\circ$] \textbf{Replace the calculation of $V_{in}$ in line 4, with calculation of \texttt{RTH1} or \texttt{RTH2} from Equation \ref{therm1} or \ref{therm2}.}

		\item[$\circ$] Replace \texttt{vin} in the \texttt{return} statement with \texttt{RTH1} or \texttt{RTH2}.
	\end{itemize}

	\item \textbf{Save your changes, copy onto your microcontroller, and test the script.}

	To test, call the function with the resistor value that corresponds to your circuit,
\begin{lstlisting}[language=Python]
rth2=therm_resistRTH2(R1=1.e5,vin=3.3)
T=thermistor_temp_celsius(Rth=rth2,A=0.,B=0.,C=0.)
print('Thermistor temperature = ',T)
\end{lstlisting}
	In the call to the \lstinline{thermistor_temp_celsius} function, remember to assign the correct values to $A$, $B$ and $C$ according to the calibration you obtained in \refsec{therm_cal}.


\end{enumerate}
\loadMilestone{mlst:04e} % load milestone with tags id: mlst:04e

%
%\vspace{4cm}
%\begin{itemize}
%	\item temperature-resistance curves
%	\item measuring resistance with a voltage divider
%	\item design and assembly of a thermister-based voltage divider
%	\item calibration and coding for thermister-based temperature measurements
%	\item refining the thermistor circuit using Kirchhoff's Law's
%\end{itemize}


\section{\color{gray} Environmental sensing with voltage: measuring electrical conductivity \color{black}}
\labsec{light_freq}
\subsection{color{gray}Electrical conductivity circuit assembly \color{black}}
\subsection{color{gray}Electrical conductivity circuit calibration \color{black}}

\section{Environmental sensing with time: measuring light intensity with frequency}
\labsec{light_freq}
Light is a key variable in the physics, chemistry and biology of most terrestrial and marine environments.
Light is an interesting and complex environmental characteristic in part because of its variable effects across the UV, visible and IR ranges of the electromagnetic spectrum, and because its intensity varies many orders of magnitude over short time and space scales.
These properties also make light a challenge to measure.

Sensors are widely available that respond to light by varying resistance, analogous to thermistors' responses to temperature.
An example is a \htmladdnormallink{photoresistor}{https://en.wikipedia.org/wiki/Photoresistor}.
We could therefore measure light with a voltage divider incorporating a photoresistor, using a very similar approach to calibration and implementation as for the thermistor voltage divider.

In this section, we will instead use an analog sensor that signals light levels using time --- specifically, the frequency of electrical pulses --- rather than voltage.
Your \texttt{ESP8266}, like many microcontrollers, can measure time intervals with relatively high resolution over a much larger range of magnitudes than its \adc can measure voltage.
As you might expect, this broad measurement range means that time-based sensors enable the \texttt{ESP8266} to quantify light with similarly higher resolution and larger intensity range, compared to voltage-based sensors.

To compound this advantage, it is very easy (using components designed for the purpose) to ``\emph{divide}'' a frequency signal -- that is, to reduce its frequency by a standard factor of 8 or 10.
If a sensor frequency approaches the upper limits of a microcontroller's measurement capabilities, dividing the signal in this way provides a reduced frequency that is within the microcontroller's limits.
It is then easy to convert the reduced frequency back to the original, with multiplication by the same factor.

To take advantage of this increase in sensor range, the circuit you will build will have two sub-circuits: One measures frequency directly from the light sensor.
The other measures the reduced frequency output from a divider.
As part of the sensor design, you will determine a suitable criterion for choosing which sub-circuit's measurements are most accurate at different light levels.

\subsection{Measuring light with frequency}
The sensor you will use in this circuit is the \htmladdnormallink{TSL237 High-Sensitivity Light-to-Frequency Converter}{https://ams.com/documents/20143/36005/TSL237\_DS000156\_3-00.pdf/4aa35672-5c5e-3bb7-4d6b-92f4c76a3531}.
Like most of the analog sensors we've considered, this sensor has three wires.
Two are the usual inputs, $GND$ and $V_{in}$.
The third is the output, $V_{data}$, which oscillates between $GND$ and $V_{in}$ at a frequency, $f$, proportional to light intensity.

Important information about this sensor is contained in the \texttt{datasheet} linked above.
The oscillation frequency in absolute darkness, $f_{dark}$, is typically around \texttt{0.1 Hz} (it varies somewhat with temperature).
The ``\texttt{full-scale frequency}'' --- the highest frequency that can be put out by the sensor --- is $f_{full}=1000kHz=1MHz$.
Figure 9 in the datasheet shows how irradiance, $E$, varies with frequency across more than 5 orders of magnitude in both quantities.

The responsiveness of the \texttt{TSL237} sensor varies with wavelength of the incident light, at maximum near 700nm and dropping to half the maximum at approximately 400nm and 875nm (Figure 10 of the datasheet).
Figures 13 and 14 show how responsiveness varies with the angle of the incident light --- it has relatively high responsiveness ($>75\%$) within roughly $30^\circ$ of the sensor's centerline.

Both color and angular variation (which are present for nearly all light sensors) often introduce some complications in interpretation of light intensity data in a specific location.
For example, across depth in an ocean or lake, the ambient light usually becomes bluer, as redder light is more quickly absorbed.
Depending on scattering by particles, the angular distribution of light rays may also broaden substantially.
Under a forest canopy, much of the ambient light might be in the green part of the spectrum, which is not absorbed by photosynthesizing plants.
In environments like these, informative metrics of light intensity may require separate measurements in different parts of the color spectrum and at different angles.

With all these caveats in mind, we can see from the datasheet that the irradiance responsivity of the \texttt{TSL237} sensor is $R_e=2.3 \frac{\mathtt{kHz}}{\mathtt{uW}/\mathtt{cm}^2}$.
This implies that a \emph{nominal irradiance} --- subject to corrections for wavelength, angle and temperature --- is given by
\begin{equation}\label{irrad}
E_e = \frac{1}{R_e} (f-f_{dark}) .
\end{equation}
Notice that, in Equation \ref{irrad}, the calculation for $R_e$ assumes frequency in units of \texttt{kHz}.
Because we typically use \htmladdnormallink{SI units}{https://en.wikipedia.org/wiki/International_System_of_Units}, we need to remember to convert from \texttt{Hz} to \texttt{kHz} when we apply this formula.

Equation \ref{irrad} gives us an approximate way to calibrate irradiation as a function of frequency, and to predict frequency for specific irradiances.
This calibration is ``approximate'' because it neglects variation between individual sensors.
It also neglects adjustments for the color and angle of incident light.

Because $f_{dark}$ is very small compared to $f$ in all situations except nearly absolute darkness, and because the errors associated with wavelength, angle and temperature are typically much larger, we can usually neglect the $f_{dark}$ term in Equation \ref{irrad}.
In that case we can simplify to a proportionality,
\begin{equation}\label{irrad2}
E_e \approx \frac{1}{R_e} f,
\end{equation}
where again $f$ is measured in \texttt{kHz}.

\subsubsection{\howto Assemble and test a frequency-based light sensor circuit}
\labsec{tsl237}
\begin{marginfigure}[-4cm]
	\begin{center}
		\htmladdnormallink{\includegraphics[width=\MFW]{Fritzing/feather_tsl237module1_bb.png}}{https://publicsensors.org/IntroSensors/Fritzing/feather_tsl237module1_bb.png}
		\caption[Light sensor sub-circuit 1 schematic]{An illustration of the circuit layout for sensing light using a \texttt{TSL237} Light-to-Frequency sensor.
		This schematic represents sub-circuit 1, in which frequency is read directly from the sensor.
		The sensor, labeled \texttt{TSL237}, is represented by an image of an \texttt{LED}, because no image of the \texttt{TSL237} is currently available in the Fritzing software.
		The 8 bottom rows on the breadboard are left open to leave room for sub-circuit 2.
		Red wires represent \texttt{3.3 volts}, black wires represent \texttt{GND}, and yellow wires represent the frequency-modulated sensor output.}
		\labfig{feather_tsl237module1}
	\end{center}
\end{marginfigure}
An example layout of the \texttt{TSL237} sub-circuit is shown in \reffig{feather_tsl237module1}.



\begin{enumerate}
	\item \textbf{Starting with the \texttt{ESP8266} and power/ground rails in their usual configurations, connect the \texttt{Vin} and \texttt{GND} pins to their respective rails.}

	The pin assignments for the \texttt{TSL237} are shown in Figure 3 of the datasheet.
	With the sensor facing upwards (the little plastic focusing hemisphere pointing up) and wires pointing towards you, \texttt{GND} is the left wire, \texttt{Vin} is the middle wire, and \texttt{Vout} is the right wire.

	\smallskip
	In the schematic, we've illustrated jumpers between the sensor and the breadboard.
	These are to make clear how the inputs and output are connected.
	These jumpers are optional --- you may connect the sensor directly into the breadboard, or use female-male jumpers between the sensor and the breadboard.

%	\smallskip
%	Very long wires between the sensor and the microcontroller can affect the sensor reading.
%	So, it's best to restrict these wires to about the length of standard jumpers.

	\item \textbf{Connect the sensor's \texttt{Vout} to \texttt{Pin 4} on the microcontroller.}

\end{enumerate}
The hardware for sub-circuit 1 is now complete.

\smallskip
To measure frequency from the \texttt{TSL237} sensor, we will first measure its \texttt{\textbf{period}}.
The period is the time taken for a complete high/low cycle of the oscillating voltage on \texttt{Pin p}.
The \texttt{TSL237}'s frequency is the inverse of this period.

To measure the period, we will use a modification of code posted on the \htmladdnormallink{MicroPython forum}{https://forum.micropython.org/viewtopic.php?f=18\&t=5724\&p=32921}:
\lstinputlisting[language=Python,label=FrequencyMedian,caption={\htmladdnormallink{\texttt{period\textunderscore median.py}}{https://github.com/publicsensors/IntroSensors/blob/main/Codes/period_median.py}: A Python function to calculate the period of an oscillating voltage.}]{Codes/period_median.py}
This code uses a \Micropython  utility called \lstinline{time_pulse_us} to measure the period, in microseconds, of the  oscillating voltage on \texttt{Pin p}.

To improve precision, the code repeats this measurement \texttt{n} times, and returns the median value.
It also returns \texttt{True} if the measurements completed without errors.
This result is presented as a Python tuple, \lstinline{(per,valid)}, where \lstinline{per} is the measured period in $\mu s$ and \lstinline{valid} is \texttt{True} for a successful measurement.

One thing to know about the \lstinline{time_pulse_us} function is that, if the pin it is monitoring does not change state within the interval \texttt{timeout}, an error is triggered.
In this case, \lstinline{time_pulse_us} returns \texttt{-1} or \texttt{-2} as an error message.
Two things happen if this error occurs.
The \lstinline{median_of_n} code returns \texttt{False} for \lstinline{valid}, flagging the error status.
Also, the  \lstinline{median_of_n} code returns the value of \texttt{timeout} for \lstinline{per}, instead of a measured period.

\emph{That is, the} \lstinline{median_of_n} \emph{code returns the either the measured pulse interval or the parameter} \lstinline{timeout}\emph{, whichever is lower}.
In other words, \texttt{timeout} is the maximum value for the period reported by \lstinline{median_of_n}, even if the true period is longer.
This is something to keep in mind as you assess the sensor measurements.

The code is designed this way for two reasons.
One is to prevent error messages from contaminating frequency estimates from the light sensor.
Spurious measurements of \texttt{-1} or \texttt{-2}, if treated like true measurements, would erroneously reduce the reported period and increase the inferred light intensity.
It could even give negative frequency values!
The other is to prevent the \lstinline{median_of_n} function from being stuck for an indefinite period if there are no pulses.
This could happen if the sensor is accidentally detached or damaged, or takes a reading in near-absolute darkness.


\begin{enumerate}[resume]
	\item \textbf{Copy the \lstinline{period_median.py} file containing the \lstinline{median_of_n} function onto your microcontroller.}
	\item \textbf{Test your light sensor circuit using the commands:}
\begin{lstlisting}[language=Python]
from period_median import median_of_n
from machine import Pin
p4 = Pin(4, Pin.IN)
timeout=300000
nrep=7
median_of_n(p4,nrep,timeout,verbose=True)
\end{lstlisting}
	These commands first import the necessary modules.
	In your circuit, \texttt{Vout} from the \texttt{TSL237} is attached to \texttt{Pin 4}, so this pin is initialized as \texttt{p4} and used in the function call.
	The parameter \texttt{timeout} is here set to \texttt{300000} $\mu s$, or \texttt{0.3 s}.
	The measurement is repeated \texttt{nrep=7} times.
	In this example, \texttt{verbose=True} is used to print out the individual measurements.
	The results will be similar to
\begin{lstlisting}[language=Python]
52 [41, 51, 52, 52, 53, 54, 54]
(52, True)
\end{lstlisting}
	The verbose output gives you a sense for the precision of successive measurements, under essentially constant ambient light conditions.

	\smallskip
	Except when testing, it's often helpful to set \lstinline{verbose=False}, to see only the second line of this output (the median of measured periods, and whether the measurements completed successfully).

	\item \textbf{Take several measurements of period under different light conditions (e.g. shade the sensor with your hand, and shine a bright light directly on it).}

	Enter the measurements of \texttt{TSL237}'s period from \lstinline{median_of_n} in one column of a spreadsheet, under the column header \texttt{Period}.

	\item \textbf{Calculate frequency from your period measurements.}

	In the next column, enter the header \texttt{Hz}.
	Next to each value in the \texttt{Period} column, enter the formula to calculate 1000000/\texttt{Period}.
	Because \lstinline{median_of_n} measures time in microseconds, this quotient is the frequency of the signal in \texttt{herz} (cycles per second, abbreviated \texttt{Hz}).

	\smallskip
	In the next column, enter the header \texttt{kHz}, representing frequency in units of \texttt{kiloherz}.
	Next to each value in \texttt{Hz} column, enter the formula to calculate \texttt{Hz}/1000.
	This column now contains your observed frequencies converted to \texttt{kHz}, which are the units expected for in Equation \ref{irrad}.

	\item \textbf{Critically assess your observations.}

	What is the largest and smallest period and frequency you observe in your tests?
	Do you see any evidence of limits to the range of the \texttt{TSL237}/\texttt{ESP8266} combination, either at high or low light intensities?
\end{enumerate}

\loadMilestone{mlst:04f} % load milestone with tags id: mlst:04f
%A ``driver'' is code designed to interface with a piece of hardware.
%In the case of your light sensor, a driver should be a function that provides a clear and intuitive way to measure light.
%\ref{irrad}

\subsection{Dividing frequency to increase sensor range}
\labsec{divider}
The sub-circuit you set up to measure light in \refsec{tsl237} should work well over a range of light conditions.
However, there are limits to this range.
At very low light levels, readings from the sensor are limited by the parameter \texttt{timeout}, which the longest pulse interval that can be measured by the \lstinline{median_of_n} script.

At very high light levels, readings are limited by the microcontroller hardware.
The \lstinline{time_pulse_us} function cannot accurately measure intervals shorter than a few microseconds.
The \texttt{tsl237} light sensor gives a frequency up to 1 $MHz$.
This corresponds to a 1 $\mu s$ pulse interval, which is much too short for the \texttt{ESP8266} to resolve.

How can we increase the range of light levels over which meaningful measurements can be taken by your \texttt{TSL237}/\texttt{ESP8266} instrument?
One approach is to add an additional sub-circuit to the existing circuit, that implements a counter/divider, called a \htmladdnormallink{CD4017B} {https://www.ti.com/lit/ds/symlink/cd4017b.pdf}.

The \texttt{CD4017B} takes in an input frequency, and outputs a frequency reduced by a factor of 10.
More specifically, it sends pulses to different pins, representing ``counts'' from 0 to 9.
A microcontroller \texttt{GPIO} attached to the \texttt{CD4017B} pin associated with one of those pins will see only every 10th input pulse.
Some periods in \texttt{TSL237} output that are too short for the \texttt{ESP8266} to measure directly can be measured after being ``lengthened'' by  this factor of 10.
As you can see from \ref{irrad2}, this extends the range of your instrument into roughly $10\times$ higher light intensities.

However, there is a tradeoff:
The longest \texttt{TSL237} period that can be measured is also reduced by a factor of 10, meaning that the range of the instrument is reduced at lower light intensities.
Also, its resolution is reduced by this same factor of 10.

Clearly, the ideal would be the best of both worlds --- to use the high resolution, direct measurement of \texttt{TSL237} when it is within the \texttt{ESP8266}'s capabilities, and to use the frequency-divided \texttt{CD4017B} output when light levels are too high for direct measurements.
The activities in this section take you through implementing this improved instrument.
First, you will build a new sub-circuit using a \texttt{CD4017B} to generate a $10\times$-reduced frequency signal.
Then, you will code a driver to automatically select between the direct and reduced frequency signals, to obtain the best light measurement.

%To identify situations in which light levels exceed the capacity of the sub-circuit constructed in \refsec{tsl237}, and to get more accurate readings in those cases, you will now add sub-circuit 2 to your sensor.
%\smallskip
%By measuring the period of signals coming from the \texttt{CD4017B}, sub-circuit 2 effectively extends your microcontroller's time measurement capacity to a ten-fold higher light intensity.

%In effect, the \texttt{CD4017B} shifts the working range of the \texttt{TSL237} to tenfold higher light intensity.
\subsubsection{\howto Measure divided frequency from a light sensor}
\labsec{cd4017b}
\begin{marginfigure}[0cm]
	\begin{center}
		\htmladdnormallink{\includegraphics[width=\MFW]{Fritzing/feather_tsl237_bb.png}}{https://publicsensors.org/IntroSensors/Fritzing/feather_tsl237_bb.png}
		\caption[Complete light sensor circuit schematic]{An illustration of the circuit layout for sensing light coupling a \texttt{CD4017B} divider/counter with a \texttt{TSL237} Light-to-Frequency sensor.
		Sub-circuit 2 is an addition to sub-circuit 1, which is not modified.
		Wire colors retain the same meaning as in sub-circuit 1, with the additional purple wire representing divided frequency from the frequency-modulated sensor output.
		in which frequency is read directly from the sensor.}
		\labfig{feather_tsl237}
	\end{center}
\end{marginfigure}
The layout for adding sub-circuit 2 to your sensor assembly is shown in \reffig{feather_tsl237}.

\begin{enumerate}
	\item \textbf{Place your \texttt{CD4017B} on the breadboard.}

	The orientation of the \texttt{CD4017B} is indicated by the semi-circular indentation on one end.
	This is the upper end, which goes closest to the microcontroller.

	\item \textbf{Connect power and ground to the \texttt{CD4017B}.}

	The pins on the \texttt{CD4017B} are explained in the \htmladdnormallink{CD4017B datasheet} {https://www.ti.com/lit/ds/symlink/cd4017b.pdf}.
	The lower left pin is \texttt{GND}.
	The upper right pin is \texttt{Vin}, which in this case is connected via the power rail to \texttt{3.3 volts} from the microcontroller.

	\smallskip
	There are two additional ground connections.
	\begin{itemize}
		\item[$\circ$] \textbf{Connect the \texttt{RESET} pin, immediately below \texttt{Vin}, to \texttt{GND}.}
		\item[$\circ$] \textbf{Connect the \texttt{CLOCK INHIBIT} pin, two rows below the \texttt{RESET} pin, to \texttt{GND}.}
	\end{itemize}
	Both these pins modify the state of the \texttt{CD4017B} in ways that are not needed in our circuit.

	\item \textbf{Connect \texttt{Vout} from the \texttt{TSL237} to the \texttt{CLOCK} pin on the \texttt{CD4017B}.}

	The \texttt{CLOCK} pin is the input frequency signal for the \texttt{CD4017B}.
	Here, we connect it to \texttt{Vout} from the \texttt{TSL237}, which carries the voltage oscillating at the frequency to be divided.

	\item \textbf{Connect the \texttt{CARRY OUT} pin on the \texttt{CD4017B} to \texttt{Pin 5} on your \texttt{ESP8266}.}

	The \texttt{CARRY OUT} pin is the \texttt{CD4017B}'s output, which has $\frac{1}{10}$th the frequency of the \texttt{CLOCK} pin input.

	\item \textbf{Test your frequency dividing circuit using the commands:}
\begin{lstlisting}[language=Python]
from period_median import median_of_n
from machine import Pin
p5 = Pin(5, Pin.IN)
timeout=300000
nrep=7
median_of_n(p5,nrep,timeout,verbose=True)
\end{lstlisting}
	Most of this code is the same as in the sub-circuit 1 test.
	The only change is in pin number, from 4 to 5.
	The results will be something like
\begin{lstlisting}[language=Python]
536 [533, 533, 534, 536, 536, 537, 538]
(536, True)
\end{lstlisting}
	\item \textbf{Repeat the assessment from \refsec{tsl237}, taking several measurements under different light conditions, calculating frequency from period, and critically assessing your observations.}

	What is the largest and smallest period and frequency you observe in the new tests?
	Do you see any evidence of changes in limits to the sensor's range, either at high or low light intensities, when the frequency signal is divided by the \texttt{CD4017B}?

\end{enumerate}
\loadMilestone{mlst:04g} % load milestone with tags id: mlst:04g



\subsection{Optimizing a light sensor driver}
\labsec{opt_driver}
With a working circuit that takes both direct and reduced frequency signals, you are now ready to code a driver to automatically select the best light measurement.

The basic idea is that, for very low light levels, you want to measure period directly from the \texttt{TSL237}.
For very high light levels, you want to measure the frequency divided period from the \texttt{CD4017B}.
At intermediate light levels, it may not matter which way you measure period, because both are acceptably accurate.

How can you determine what is ``high'', ``low'' and ``intermediate'' for your instrument?
One simple approach is to construct a log-log plot, with direct period measurements on the vertical axis and divided period measurements on the horizontal axis.
In such a plot, we expect that within the ``intermediate'' range --- where both methods are accurate --- the measurements will fall on the $1:10$ line.

We also expect that, at very high light levels, the direct measurements will ``bottom-out'' --- that is, they'll reach the smallest measurable interval on the \texttt{ESP8266} --- while the divided measurements continue to decrease.
If so, those points on the plot will lie above the $1:10$ line, and their vertical coordinates will never be below the smallest measurable interval.

Conversely, at very low light levels, the divided measurements will ``top-out'' --- that is, they'll reach the \texttt{timeout} limit --- while the direct measurements continue to increase.
If so, those points on the plot will lie above the $1:10$ line, and their horizontal coordinates will never be above the \texttt{timeout} limit.


\begin{marginfigure}[-8cm]
	\begin{center}
		\htmladdnormallink{\includegraphics[width=\MFW]{Images/period_tsl237_divider.png}}{https://publicsensors.org/IntroSensors/Images/period_tsl237_divider.png}
		\caption[Periods from a light sensor and frequency divider]{Comparison of periods measured directly from a \texttt{TSL237} Light-to-Frequency sensor \textit{vs.} through a \texttt{CD4017B} counter/divider.
			Note the \texttt{1:10} offsets in axis scales.
			The black dotted line is the \texttt{1:10} line.
			Because the divider reduces frequency 10-fold, the true ratio of periods (aside from signal noise) lies exactly on this line.
			Deviations from the line indicate limits to one or both period measurements at high or low light levels.}
		\labfig{period_tsl237_divider}
	\end{center}
\end{marginfigure}

\reffig{period_tsl237_divider} is an example of such a plot.
Each blue dot in this figure represents a coordinate pair of divided and direct period measurements.
The black dotted line is the $1:10$ line.
The blue dotted lines represent an approximate smallest measurable interval on the \texttt{ESP8266}, \texttt{4} $\mu s$, inferred from the deviations of the measurements from the $1:10$ line at high frequencies.
The red dotted lines represent the \texttt{timeout} limit used to collect these data --- in this case, \texttt{300000} $\mu s$.

\subsubsection{\howto Optimize a light sensor driver}
\labsec{optdriver}
In this activity, you will use the drivers you wrote in \refsec{tsl237} and \refsec{cd4017b} and the information in \reffig{period_tsl237_divider} to code an ``optimized'' driver that automatically selects the more accurate between direct and divided period measurements.

Here, ``optimized'' means two things:
\begin{itemize}
	\item[$\circ$] If one measurement method is in an inaccurate part of its range, the driver will always choose the alternative, more accurate measurement.
	\item[$\circ$] If both measurement methods are acceptably accurate, it will use the fastest method.
\end{itemize}
Both these criteria are met by an algorithm that first makes a measurement using the direct driver, and accepts it if the period is well above the lower threshold of \texttt{4} $\mu s$.
If the direct period is below the threshold, it remeasures using the divided driver and accepts its value as the better measurement.
\begin{enumerate}
	\item \textbf{Define a new function,} \lstinline{read_optTSL237}\textbf{, in your} \lstinline{readTSL237div.py} \textbf{file.}

	This function will implement the optimization algorithm.
	The arguments of this function are: the pins assignments for both direct and divided measurements; the \lstinline{timeout} and \lstinline{nrep} parameters required by \lstinline{median_of_n}; and, a new parameter called \lstinline{thresh_per}.

	\smallskip
	\lstinline{thresh_per} is the threshold your new function will use to decide whether the directly measured period is unacceptably low.
	Use a default value somewhat above the  \texttt{4} $\mu s$, to leave a margin of safety.

	\item \textbf{Calculate the frequency corresponding to the threshold period,} \lstinline{thresh_per}.

	Save it under an informative name like \lstinline{f_thresh}.

	\item \textbf{Use Equation \ref{irrad} to calculate the nominal irradiance corresponding to} \lstinline{f_thresh}.

	Save its value with an informative name, like \lstinline{E_E_thresh}.

	\item \textbf{In the body of the new function, evaluate the nominal irradiance $E_e$ using your} \lstinline{readTSL237} \textbf{driver.}

	Save its value with an informative name, like \lstinline{E_E_dir}.

	\item \textbf{Use an} \lstinline{if} \textbf{statement to return} \lstinline{E_E_dir} \textbf{20} \lstinline{E_E_thresh}.

	\item \textbf{Otherwise evaluate the nominal irradiance using your} \lstinline{read_divTSL237} \textbf{driver.}

	Save its value with an informative name, like \lstinline{E_E_div}, and return its value.
\end{enumerate}

\loadMilestone{mlst:04h} % load milestone with tags id: mlst:04h


%This plot was constructed in two steps:
%\begin{enumerate}
%	\item The Python script, \lstinline{light_freq.py}, was copied onto the microcontroller.
%	A listing and link for this file are given in Appendix \ref{LightFreq}.
%	Then, the function \lstinline{record_tsl237_divider} was used to tabulate comparisons of direct and frequency-divided periods, with the commands:
%	\begin{lstlisting}[language=Python]
%	from light_freq import record_tsl237_divider
%	from machine import Pin
%
%	p4 = Pin(4, Pin.IN) # p4 measures directly from the TSL237
%	p5 = Pin(5, Pin.IN) # p5 measures through the CD4017B
%	record_tsl237_divider(p_tsl237=4,p_div=5, \
%	   timeout=300000,nrep=7,navg=8,divide=10.,nsample=5, \
%	   filename='DG_tsl237_divider.dat')
%	\end{lstlisting}
%
%
%\end{enumerate}




%\reffig{period_tsl237_divider}
%
%\ref{PlotFreq}


%\lstinputlisting[language=Python,label=LightFreq,caption={\htmladdnormallink{\texttt{light\textunderscore freq.py}}{https://github.com/publicsensors/IntroSensors/blob/main/Codes/light_freq.py}: Python functions to obtain and record direct and frequency-divided measurements of period from a \texttt{TSL237} light sensor.}]{Codes/light_freq.py}








\vspace{4cm}

%https://www.amazon.com/gp/product/B01GMYPSWM/ref=ppx_od_dt_b_asin_title_s00?ie=UTF8&psc=1


\section[\color{gray} Environmental sensing with time \color{black}]{Environmental sensing with time: calibrate an acoustic distance sensor}
\labsec{cal_sonar}
\begin{itemize}
	\item
\end{itemize}

\section{\color{gray} Environmental sensing with magnetism: measuring current and wind velocity \color{black}}
\labsec{velocity}
\begin{itemize}
	\item
\end{itemize}






%\loadMilestone{mlst:03a} % load milestone with tags id: mlst:02
